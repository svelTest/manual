{"name":"Manual","tagline":"svelTest Language Reference Manual","body":"svelTest Language Reference Manual\r\n==================================\r\nWelcome! This is the documentation for svelTest. Last updated May 10, 2014.\r\n\r\nFor new programmers, our [tutorial](http://sveltest.github.io/tutorial) is a great resource to help you get started.\r\n\r\n# Table of Contents\r\n1. [Introduction](#introduction)\r\n2. [Lexical Conventions](#lexical-conventions)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 2.1 [Tokens](#tokens)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 2.2 [Comments](#comments)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 2.3 [Identifiers](#identifiers)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 2.4 [Keywords](#keywords)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 2.5 [Reserved](#reserved)\r\n3. [Types](#types)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 3.1 [Basic Types](#basic-types)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1.1 [int](#tokens)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1.2 [double](#double)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1.3 [boolean](#boolean)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1.4 [string](#string)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1.5 [file](#file)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 3.2 [Derived Types](#derived-types)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.1 [Arrays](#arrays)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.2 [Functions](#functions)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.3 [input](#input)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.4 [output](#output)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.5 [funct](#funct)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.5.1 [assert](#assert)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.5.2 [The lang Declaration](#the-lang-declaration)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.5.3 [funct Restrictions](#funct-restrictions)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2.5.4 [funct Helper Files](#funct-helper-files)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 3.3 [Constants](#constants)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.3.1 [char constants](#char-constants)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.3.2 [boolean constants](#boolean-constants)\r\n4. [Input/Output](#input--output)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 4.1 [print](#print)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 4.2 [Reading from files](#reading-from-files)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 4.3 [Writing to files](#writing-to-files)\r\n5. [Scope](#scope)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 5.1 [Lexical Scope](#lexical-scope)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 5.2 [Global Scope](#global-scope)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 5.3 [Function Scope](#function-scope)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 5.4 [Statement Block Scope](#statement-block-scope)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 5.5 [Scope of Functions](#scope-of-functions)\r\n6. [Expressions](#expressions)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.1 [Primary Expressions](#primary-expressions)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.2 [Function Calls](#function-calls)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.3 [Multiplicative Operators](#multiplicative-operators)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.4 [Additive Operators](#additive-operators)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.5 [Relational Operators](#relational-operators)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.6 [Equality Operators](#equality-operators)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.7 [Logical AND Operator](#logical-and-operator)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.8 [Logical OR Operator](#logical-or-operator)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.9 [Assignment Expression](#assignment-expression)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.10 [Declarations and Definitions](#declarations-and-definitions)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp; 6.11 [Statements](#statments)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.11.1 [Expression Statement](#expression-statement)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.11.2 [If-Else Statements](#if-else-statements)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.11.3 [Loop Statements](#loop-statements)\r\n7. [Grammar](#grammar)\r\n\r\n# Introduction\r\n\r\nThis manual describes the svelTest programming language, which provides numerous features to simplify the testing of production-level code. This manual follows the structure of Kernighan and Ritchie’s C Reference Manual, starting with a look at svelTest’s lexical conventions, its syntax, and finally its grammar.\r\n\r\n# Lexical Conventions\r\n## Tokens\r\nsvelTest has six classes of tokens: identifiers, keywords, constants, string literals, operators, and other separators. The compiler considers blanks, tabs, newlines, and comments “whitespace”. Any whitespace is ignored by the compiler except when separating tokens.\r\n\r\n## Comments\r\nsvelTest uses double forward slashes (`//`) for single-line comments, which terminate at the newline character.  Block comments use the standard forward slash-asterisk combination (`/*`), and may not be nested or exist in literal types.  A comment is treated by the compiler as a whitespace character and may exist anywhere a whitespace character is allowed.  The user cannot include comments within tokens.  The compiler ignores all characters in a comment.\r\n\r\n```\r\n// This is an inline comment\r\n```\r\n\r\n```\r\n/* This is a\r\nblock comment */\r\n```\r\n```\r\n/* This is also\r\n* a block comment\r\n*/\r\n```\r\n\r\n## Identifiers\r\nAn identifier is a token which names a svelTest language entity.  A token may consist of alphanumeric sequences of any length with underscores allowed, but cannot start with a number.  An identifier can represent a primitive, object, or function.\r\n\r\n## Keywords\r\nThe following identifiers are reserved for use as keywords, and may not be used otherwise.\r\n\r\n\r\nControl flow | svelTest primitives | Other primitives\r\n-------------|---------------------|-----------------\r\n`if` \t|\t`funct`\t\t|\t`int`\r\n`else`\t|\t`input`\t|\t`boolean`\r\n`for`\t|\t`output`\t\t|\t`char`\r\n`while`\t|\t`file`\t\t|\t`double`\r\n`return`\t|\t`__main__`\t|\t`string`\r\n`break`\t|\t`verbose`\t\t|\t`void`\r\n`continue`|\t`lang`\t\t|\t`null`\r\n`true`\t|\t\t\t|\r\n`false`\t|\t\t\t|\r\n\r\nThe following function names are also reserved:\r\n\r\nStandard | Array functions | File reading\r\n---------|-----------------|-------------\r\n`main`\t| \t`size`\t| `readlines`\r\n`print`\t| \t`append`|\r\n`assert`| \t`insert`|\r\n`int`\t|\t`remove`|\r\n`double`|\t`replace`|\r\n`boolean`|\t\t|\r\n`string`|\t\t|\r\n\r\n\r\nNote that the following Python keywords are also reserved, as svelTest programs compile to Python code:\r\n\r\n\t|\t\t|\t\t|\r\n---------|-----------------|-------------\r\n`and`\t|\t`exec`\t|\t`lambda`\r\n`as`\t|\t`finally`\t|\t`None`\r\n`class`\t|\t`from`\t|\t`not`\r\n`def`\t|\t`global`\t|\t`or`\r\n`del`\t|\t`import`\t|\t`pass`\r\n`elif`\t|\t`in`\t|\t`raise`\r\n`except`\t|\t`is`\t| \t`try`\r\n`with`\t|\t`yield`\t|\r\n\r\nWhen the declaring a new `funct` object, the user specifies the source code parameter type with this template:\r\n\r\n`languageAbbreviation_type` (ex: `j_byte` for a Java byte, `j_long` for a Java long, etc.).  We currently support all Java 1.6, Python 2.x, and C99 primitive data types. A full list of these primitives and their styling can be found in Appendix A.\r\n\r\n## Reserved\r\nThe following list contains characters that are reserved for use in our grammar. They may not be used in identifiers or for any purpose other than their intended use in our language.\r\n\r\n( ) [ ] { } ; : , .\r\n\r\n\\+ - ++ -- * / < > <= >= == = != \r\n\r\n&& || ! \\ ' \"\r\n\r\n# Types\r\n\r\n## Basic Types\r\nsvelTest has 5 primitive types.\r\n\r\n### int\r\nThe `int` data type represents signed integer values. Similar to the implementation in Python 2.7.x, an `int` is a two’s complement constant, is 31 bits in size, and has a range from -2147483648 through 2147483647, inclusive.\r\n\r\n### double\r\nThe `double` data type represents machine-level double precision floating point numbers.  Similar to Python 2.7.x, the accepted range and overflow handling is dependent on your underlying machine architecture. \r\n\r\n### boolean\r\nThe `boolean` type represents a logical quantity with two possible values, indicated by the reserved keywords `true` and `false`. Similar to Python 2.7.x, a `boolean` is a subtype of plain integers, and `boolean` values `true` and `false` behave like the integer values 1 and 0, respectively.\r\n\r\n### string\r\nA `string` is an immutable sequence of characters surrounded by double quotation marks. There is no separate character type; a character is simply a `string` of length one. Similar to Python 2.7.x, characters have a size of (at least) 8-bits.\r\n\r\n### file\r\nThe `file` type is used to reference an ASCII file relative to the user’s working directory. The `file` type is a subtype of the `string` type. It contains a string that specifies the relative path from the .svel file. If the file does not exist in the path specified, the svelTest compiler will fail and throw an error.\r\n\r\n```\r\nfile f = “src/Foo.java”;\r\n```\r\n\r\nA `file` type is used to specify the source code file (*.java, *.c, *.py) that contains the function or program to test. A file type can also be used to specify an ASCII file with the extension *.txt; this provides the option for a svelTest programmer to parse a .txt file for inputs and outputs. \r\n\r\nAlternatively, a file name could first be specified as a string and then used to create the file, like so:\r\n\r\n```\r\nString filename = “../lib/thisFile.java”;\r\nfile thisFile = filename;\r\n```\r\n\r\nThese `int`, `double`, `boolean`, and `string` primitive types may be cast to other types with the library functions `int()`, `double()`, `boolean()`, `string()`.\r\n\r\n## Derived Types\r\nBesides the basic types, there is a conceptually infinite class of derived types constructed from the fundamental types in the following ways:\r\n- arrays of objects of a given type\r\n- functions returning objects of a given type\r\n\r\n\r\nAlong with the common array and function, svelTest has three additional derived types: `input`, `output`, and `funct`.\r\n\r\n### Arrays\r\nThe user can initialize an array with inputs in curly brackets, or use the `append()` function to add an element to the end of an existing array. Note that if the user wishes to insert values into an empty array, the user must first initialize the array as empty with curly brackets. svelTest arrays follow zero-based numbering.\r\n\r\n```\r\nint[] a = {1, 2, 3}; // valid inline declaration\r\n\r\nint[] b = {};\r\nb.append(1);    \r\nb.append(2);    \r\nb.append(3); \r\n// b is now {1, 2, 3}\r\n\r\nint i = a[0]; // 1\r\n```\r\n\r\nOther supported array functions are `remove()`, `insert()`, `size()`, and `replace()`. Examples of these functions are outlined below:\r\n\r\n```\r\nint[] c = {1, 2, 3};\r\n// Prototype: a.remove(int index) \r\n// Removes object at the specified index and returns it\r\nc.remove(2); // returns 3, list is now {1, 2}\r\n\r\nint[] d = {1, 2, 3};\r\n// Prototype: array.size()\r\n// Takes zero arguments.\r\nint j = d.size(); // 3\r\n\r\nint[] e = {1, 2, 3};\r\n// Prototype: a.insert(int index, Type t) \r\n// Inserts and pushes back.\r\ne.insert(0, 4); // {4, 1, 2, 3}\r\n\r\nint[] f = {1, 2, 3};\r\n// Prototype: a.replace(int index, Type t);\r\n// Replaces object at the index and returns the old object.\r\nf.replace(0, 4); // {4, 2, 3}\r\n```\r\n\r\n### Functions\r\nA function is declared by specifying a return type (or `void`), name, and any parameters. For example, we have a function prototype for an add function that takes two integers as parameters and returns an integer:\r\n```\r\nint add(int x, int y)\r\n```\r\n### input\r\nThe input data type is a wrapper for an n-sized tuple, where n represents the number of parameters of the method to test. Each value in the tuple can take the type of any data type, including those in the source code language. An input is used to specify a set of actual parameters for any method the user wants to test. Parentheses are used to denote a set of actual parameters as an input type, and commas are used to separate each parameter.\r\n\r\n```\r\ninput empty = (); // method to test takes no parameters\r\ninput single = (3); // takes a single parameter of type int\r\ninput multiple = (“Hello World”, true); // takes two params\r\n```\r\n\r\n### output\r\nThe output data type is a wrapper for the expected return value of the method to test. The value of an output can take the type of any source code language data type.\r\n```\r\noutput out = \"Hello World!\";\r\n```\r\n\r\n### funct\r\nThe funct type is a wrapper to specify the method to test. A funct has three fields: the method name denoted by a string, the set of the formal parameters of the method denoted using parentheses and commas, and the file type that specifies where the method is defined. The three fields are surrounded with brackets { } and separated by commas.\r\n\r\n```\r\nfile f = “src/Add.java”;\r\nfunct add = {“add”, (j_int, j_int), f};\r\n```\r\n\r\nIn the example above, the Add.java class file contains the method with the method signature that has the name “add”, and takes two Java ints as parameters. The keyword __main__ can be used to specify that the entire program should be run. (Note that the user could also specify “main” as the method name.) If the specified method does not exist in the file, the compiler will raise an error.\r\n\r\n#### assert\r\nAn object of type funct has a reserved, built-in method called assert(). The assert() method returns a boolean and takes in two parameters: an input type and output type. \r\n\r\n```\r\nboolean assert(input, output)\r\n```\r\n\r\nWhen the assert() method is called via an object of type funct, the method specified by the funct object will be tested with the given input parameters. The actual return value or contents of standard output will be validated against the expected return value or standard output contents. If the actual return value or console contents matches the expected, assert() returns true. Otherwise, it will return false.\r\n\r\n```\r\ninput in = (1, 1);\r\noutput out = (2);\r\nif (add.assert(in, out)) {\r\n    print(“add passed.”);\r\n} else {\r\n    print(“add failed.”); \r\n}\r\n```\r\n\r\nPython’s “==” equality operator is used to test for equality between the expected output and the actual output of the function being tested. If the user wishes to test the output of a non-primitive object, that user must write their own toString() method for that object, as svelTest compares output by string representation.\r\n\r\nThe assert method also has an optional third argument, verbose. Specifying verbose as the third argument adds additional functionality to assert(): instead of just returning true or false, assert will also print test information to standard output for you.\r\n\r\n```\r\nfib.assert(4, 3, verbose);\r\n// Output: fib(4)...        PASS\r\n```\r\n\r\n#### The lang Declaration\r\nIn order for assert() to know what kind of code you’re testing, every svelTest file must start with a lang declaration. Currently supported lang types are Java, C, Python, and None. lang declarations are of this form:\r\n\r\n```        \r\nlang = Java;\r\n```\r\n\r\n#### funct Restrictions\r\nDepending on which language is being tested, there are some restrictions on what kinds of functions can be tested successfully with funct.\r\n\r\n#####Java\r\nAny public static function that takes Java primitives or void (including the main() method)\r\n\r\n#####C\r\nAny main() method that C primitives or void\r\n\r\nAny method that takes C primitives or void contained in a file not also containing a main() method\r\n\r\n#####Python:\r\nAny “main” method i.e. the equivalent of running `python <file_to_test>.py` and testing the output\r\n\r\nAny function contained within a class definition\r\n\r\nAny of the above functions that do not return primitives/void can be tested as long as the returned value can be compared with a toString() method written by the user.\r\n\r\n#### funct Helper Files\r\nfunct may create some helper files at runtime. For example, you may write addTester.svel to test the public static function add() contained in Add.java. Your code will compile to addTester.py; upon running addTester.py, the helper file Sveladd.java will be created and compiled. This allows the program to test add() individually rather than having to use the entire Add.java class. \r\n\r\nNote that these helper files are not removed after addTester.py finishes execution. This is for efficiency reasons: rather than creating, compiling, deleting, and repeating the entire process for every execution of assert(), the helper files are created and compiled only once. We suggest creating a Makefile with a target “clean” to remove all Svel* files after you’re done testing, or simply using a command like rm Svel*.\r\n\r\n## Constants\r\n\r\n### char constants\r\n\r\nSpecial constants that are reserved or cannot be represented without conventional keys are represented with escape sequences.\r\n\r\n* newline&nbsp;&nbsp;&nbsp;&nbsp;\\n\r\n* horizontal tab&nbsp;&nbsp;&nbsp;&nbsp;\\t\r\n* carriage return&nbsp;&nbsp;&nbsp;&nbsp;\\r\r\n* backslash&nbsp;&nbsp;&nbsp;&nbsp;\\\\ \\\\\r\n* single quote&nbsp;&nbsp;&nbsp;&nbsp;\\’\r\n* double quote&nbsp;&nbsp;&nbsp;&nbsp;\\”\r\n\r\n### boolean constants\r\nA boolean can either take the value true or false.\r\n\r\n# Input/Output\r\n\r\n## print\r\nsvelTest users may send values to Standard Out using the print function.  print takes in variables of any type, converting any non-string types to strings on-the fly.\r\n\r\n```\r\nprint(“Hello World!”); // prints Hello World!\r\n\r\nint a = 1;\r\nprint(a); // prints 1\r\nint b = 2;\r\nprint(b); // prints 2\r\nint c = a + b;\r\nprint(c); // prints 3\r\n\r\nboolean bl = true;\r\nprint(bl); // prints true\r\n```\r\n\r\n## Reading from Files\r\nAs outlined above, the file type is used to reference an ASCII file relative to the user’s working directory. They use may use the file type to load a source code file, or a file containing streams of inputs and outputs.\r\n\r\n```\r\nfile f = “../Foo.java”;\r\nfile g = “inputs.txt”;\r\nfile h = “outputs.txt”;\r\n```\r\n\r\nThe file type has the reserved, built-in function readlines() that reads the entire contents of a file into a string array. The trailing newline character on each is not kept in the string.\r\n\r\n```\r\n// testcases.txt\r\n// 0\r\n// 1\r\n// 2\r\n\r\nfile testcases = \"testcases.txt\";\r\nstring[] lines = testcases.readlines();\r\nprint(lines); // ['0', '1', '2']\r\n```\r\n\r\n## Writing to Files\r\nThe user may not create new files or write to existing files in a svelTest program. If a user wishes to write the output of a svelTest program to a file, they may use the ‘>’ character to redirect the contents of standard out to a new file of their choice in their favorite shell.\r\n\r\n# Scope\r\nThe scope of a declaration is the region within the svel program which the entity declared by the declaration can be referred to using the name of the entity. The svelTest compiler will catch any scoping issues.\r\n\r\n## Lexical Scope\r\nA code block defines the scope of a variable. Variables declared in a specific scope are not visible from outside that block. Furthermore, variables declared in the same scope must have unique names.\r\n\r\n## Global Scope\r\nVariables declared outside of functions are considered to have a global scope.  These variables exist in all other scopes throughout the program.\r\n\r\n## Function Scope\r\nVariables declared inside functions exist only within the scope of that function, and die upon the termination of that function.\r\n\r\n## Statement Block Scope\r\nVariables declared inside statement blocks exist only within the scope of that statement, and die upon leaving the block.\r\n\r\n## Scope of Functions\r\nsvelTest requires users to define a function before using it. For example, the following syntax is not valid:\r\n\r\n```\r\nmain() { \r\nnotDefined(); \r\n}\r\n\r\nvoid notDefined() {\r\n    print “This function is not defined correctly.”;\r\n}\r\n```\r\n\r\n```\r\nThe following syntax is valid:\r\nvoid defined() {\r\n    print(“This function is defined correctly.”);\r\n}\r\n\r\nmain() {\r\n    defined();\r\n}\r\n```\r\n\r\n# Expressions\r\n\r\n## Primary Expressions\r\n\r\nPrimary expressions are identifiers, constants, or strings.  Constants are defined by a number (integer), decimal number, true and false boolean statements, function calls, and reference types (for accessing array elements).\r\n\r\n```\r\nprimary_expr : \tID\r\n \t     | STRINGLITERAL\r\n \t     | NUMBER\r\n\t     | DECIMAL\r\n\t     | TRUE\r\n\t     | FALSE\r\n\t     | function_call\r\n\t     | ref_type\r\n```\r\n\r\n## Function Calls\r\nA function call is a postfix expression that consists of a function name and parameter list surrounded by parentheses.  Casting to the various data types is also done through Function calls.\r\n\r\n```\r\nfunction_call : ID LPAREN identifier_list RPAREN\r\n                | STRING LPAREN logical_OR_expr RPAREN\r\n                | INT LPAREN logical_OR_expr RPAREN\r\n                | BOOLEAN LPAREN logical_OR_expr RPAREN\r\n                | DOUBLE LPAREN logical_OR_expr RPAREN\r\n                | PRINT LPAREN logical_OR_expr RPAREN\r\n                | ID PERIOD lib_function LPAREN identifier_list RPAREN\r\n```\r\n\r\n## Multiplicative Operators\r\nThe multiplicative operators are * (multiplication) and / (division), and group left-to-right.\r\n\r\n```\r\nmultiplicative_expr : secondary_expr\r\n                    | multiplicative_expr TIMES secondary_expr\r\n                    | multiplicative_expr DIVIDE secondary_expr\r\n```\r\n\r\nThe modulus operation is not supported in svelTest.\r\n\r\n## Additive Operators\r\nThe additive operators are + (addition) and - (subtraction), and group left-to-right.\r\n\r\n```\r\nadditive_expr : multiplicative_expr\r\n            | additive_expr PLUS multiplicative_expr\r\n            | additive_expr MINUS multiplicative_expr\r\n```\r\n\r\n## Relational Operators\r\nThe relational operators are < (less), > (greater), <= (less or equal), >= (greater or equal).\r\n\r\n```\r\nrelational_expr : additive_expr\r\n                | relational_expr LS_OP additive_expr\r\n                | relational_expr LE_OP additive_expr\r\n                | relational_expr GR_OP additive_expr\r\n                | relational_expr GE_OP additive_expr\r\n```\r\n\r\n## Equality Operators\r\nThe equality operators are == (equal to) and != (not equal to), and have lower precedence than the relational operators.\r\n\r\n```\r\nequality_expr : relational_expr\r\n            | equality_expr EQ relational_expr\r\n            | equality_expr NEQ relational_expr\r\n```\r\n\r\n## Logical AND Operator\r\nThe logical AND (&&) operator groups left-to-right.\r\n\r\n```\r\nlogical_AND_expr : equality_expr\r\n                | logical_AND_expr AND equality_expr\r\n```\r\n\r\n## Logical OR Operator\r\nThe logical OR (||) operator groups left-to-right.\r\n\r\n```\r\nlogical_OR_expr : logical_AND_expr\r\n                | logical_OR_expr OR logical_AND_expr\r\n```\r\n\r\n## Assignment Expression\r\nAssignment expressions evaluate right-to-left.  The left operand must be an identifier. svelTest is statically typed.\r\n\r\n```\r\nassignment_expr : FUNCT ID ASSIGN LBRACE funct_name COMMA LPAREN reserved_languages_list RPAREN COMMA primary_expr RBRACE\r\n                | type ID ASSIGN assignment_expr\r\n                | ID ASSIGN assignment_expr\r\n                | logical_OR_expr\r\n```\r\n\r\n## Declarations and Definitions\r\nDeclarations specify how an identifier should be interpreted and do not necessarily reserve storage.\r\n\r\n```\r\nexternal_declaration : function_def\r\n                    | type ID SEMICOLON\r\n                    | type ID ASSIGN assignment_expr SEMICOLON\r\n```\r\n\r\nDefinitions also specify how an identifier should be interpreted and do reserve storage.\r\n\r\n```\r\nfunction_def : VOID ID LPAREN param_list RPAREN brack_stmt\r\n | type ID LPAREN param_list RPAREN brack_stmt\r\n | MAIN LPAREN param_list RPAREN brack_stmt\r\n```\r\n\r\n## Statements\r\nStatements are executed for their effect, and do not have values.  In addition, statements are normally executed in sequence.\r\n\r\n```\r\nstmts : stmts stmt\r\n    | stmt\r\n    | brack_stmt\r\n\r\nstmt : expression_stmt\r\n     | ifelse_stmt\r\n     | loop_stmt\r\n     | jump_stmt\r\n```\r\n\r\n### Expression Statement\r\nExpressions ended with a semicolon (;) are Expression Statements. The result of the expression statement evaluation is not stored unless explicitly reassigned to a new identifier.\r\n\r\n```\r\nexpression_stmt : expression SEMICOLON\r\n\r\nexpression : assignment_expr\r\n            | type ID\r\n            | empty\r\n```\r\n\r\n### If-Else Statements\r\nIf-else statements define the if and if-else control-flow mechanisms.\r\n\r\n```\r\nifelse_stmt : IF LPAREN expression RPAREN brack_stmt\r\n            | IF LPAREN expression RPAREN brack_stmt ELSE brack_stmt\r\n```\r\n\r\nThe expression contained within the parentheses is evaluated as a boolean or boolean equivalent. If this expression is true, the first statement is evaluated. If the expression is false the statement following the else is evaluated, or none in the case that there is no else.\r\n\r\nThe ambiguity of the dangling-else problem is handled by binding each else to the nearest if statement.\r\n\r\n### Loop Statements\r\nLoop statements define the the while and for looping mechanisms.\r\n\r\n```\r\nloop_stmt : WHILE LPAREN expression RPAREN brack_stmt\r\n        | FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN brack_stmt\r\n```\r\n\r\nThe while loop works by first evaluating the expression contained within the parentheses and executing the statement if the expression evaluates to true. The loop will continue to evaluate this expression before each iteration until it evaluates to false, at which point the loop will terminate.\r\n\r\nThe first expression of the for loop is evaluated once and is generally used for the initialization mechanism of loop. The second expression is evaluated before each iteration of the for loop and is analogous to the parenthesized expression in the while loop. Note that a missing second expression will be evaluated to true. The third and final expression is evaluated at the end of each iteration, after the statement has been executed, and is generally used to update the state of the loop (e.g. a counter).\r\n\r\n# Grammar\r\n```\r\nRule 0     S' -> outer_unit\r\nRule 1     outer_unit -> lang_def translation_unit\r\nRule 2     lang_def -> LANG ASSIGN ID SEMICOLON\r\nRule 3     lang_def -> LANG ASSIGN NONE SEMICOLON\r\nRule 4     translation_unit -> external_declaration\r\nRule 5     translation_unit -> translation_unit external_declaration\r\nRule 6     external_declaration -> function_def\r\nRule 7     external_declaration -> type ID SEMICOLON\r\nRule 8     external_declaration -> type ID ASSIGN assignment_expr SEMICOLON\r\nRule 9     function_def -> VOID ID LPAREN param_list RPAREN brack_stmt\r\nRule 10    function_def -> type ID LPAREN param_list RPAREN brack_stmt\r\nRule 11    function_def -> MAIN LPAREN param_list RPAREN brack_stmt\r\nRule 12    type -> INT\r\nRule 13    type -> DOUBLE\r\nRule 14    type -> BOOLEAN\r\nRule 15    type -> CHAR\r\nRule 16    type -> STRING\r\nRule 17    type -> FUNCT\r\nRule 18    type -> INPUT\r\nRule 19    type -> OUTPUT\r\nRule 20    type -> FILE\r\nRule 21    type -> type LBRACKET RBRACKET\r\nRule 22    ref_type -> ID LBRACKET assignment_expr RBRACKET\r\nRule 23    param_list -> param_list COMMA parameter\r\nRule 24    param_list -> parameter\r\nRule 25    parameter -> type ID\r\nRule 26    parameter -> empty\r\nRule 27    brack_stmt -> LBRACE stmts RBRACE\r\nRule 28    stmts -> stmts stmt\r\nRule 29    stmts -> stmt\r\nRule 30    stmts -> brack_stmt\r\nRule 31    stmt -> expression_stmt\r\nRule 32    stmt -> ifelse_stmt\r\nRule 33    stmt -> loop_stmt\r\nRule 34    stmt -> jump_stmt\r\nRule 35    expression_stmt -> expression SEMICOLON\r\nRule 36    expression -> assignment_expr\r\nRule 37    expression -> type ID\r\nRule 38    expression -> empty\r\nRule 39    assignment_expr -> FUNCT ID ASSIGN LBRACE funct_name COMMA LPAREN reserved_languages_list RPAREN COMMA primary_expr RBRACE\r\nRule 40    assignment_expr -> type ID ASSIGN assignment_expr\r\nRule 41    assignment_expr -> ID ASSIGN assignment_expr\r\nRule 42    assignment_expr -> logical_OR_expr\r\nRule 43    funct_name -> __MAIN__\r\nRule 44    funct_name -> primary_expr\r\nRule 45    logical_OR_expr -> logical_AND_expr\r\nRule 46    logical_OR_expr -> logical_OR_expr OR logical_AND_expr\r\nRule 47    logical_AND_expr -> equality_expr\r\nRule 48    logical_AND_expr -> logical_AND_expr AND equality_expr\r\nRule 49    equality_expr -> relational_expr\r\nRule 50    equality_expr -> equality_expr EQ relational_expr\r\nRule 51    equality_expr -> equality_expr NEQ relational_expr\r\nRule 52    relational_expr -> additive_expr\r\nRule 53    relational_expr -> relational_expr LS_OP additive_expr\r\nRule 54    relational_expr -> relational_expr LE_OP additive_expr\r\nRule 55    relational_expr -> relational_expr GR_OP additive_expr\r\nRule 56    relational_expr -> relational_expr GE_OP additive_expr\r\nRule 57    additive_expr -> multiplicative_expr\r\nRule 58    additive_expr -> additive_expr PLUS multiplicative_expr\r\nRule 59    additive_expr -> additive_expr MINUS multiplicative_expr\r\nRule 60    multiplicative_expr -> secondary_expr\r\nRule 61    multiplicative_expr -> multiplicative_expr TIMES secondary_expr\r\nRule 62    multiplicative_expr -> multiplicative_expr DIVIDE secondary_expr\r\nRule 63    secondary_expr -> primary_expr\r\nRule 64    secondary_expr -> LPAREN identifier_list RPAREN\r\nRule 65    secondary_expr -> LBRACE identifier_list RBRACE\r\nRule 66    primary_expr -> ID\r\nRule 67    primary_expr -> STRINGLITERAL\r\nRule 68    primary_expr -> NUMBER\r\nRule 69    primary_expr -> DECIMAL\r\nRule 70    primary_expr -> TRUE\r\nRule 71    primary_expr -> FALSE\r\nRule 72    primary_expr -> function_call\r\nRule 73    primary_expr -> ref_type\r\nRule 74    function_call -> ID LPAREN identifier_list RPAREN\r\nRule 75    function_call -> STRING LPAREN logical_OR_expr RPAREN\r\nRule 76    function_call -> INT LPAREN logical_OR_expr RPAREN\r\nRule 77    function_call -> BOOLEAN LPAREN logical_OR_expr RPAREN\r\nRule 78    function_call -> DOUBLE LPAREN logical_OR_expr RPAREN\r\nRule 79    function_call -> PRINT LPAREN logical_OR_expr RPAREN\r\nRule 80    function_call -> ID PERIOD lib_function LPAREN identifier_list RPAREN\r\nRule 81    lib_function -> ASSERT\r\nRule 82    lib_function -> REMOVE\r\nRule 83    lib_function -> SIZE\r\nRule 84    lib_function -> INSERT\r\nRule 85    lib_function -> REPLACE\r\nRule 86    lib_function -> READLINES\r\nRule 87    reserved_languages_list -> reserved_language_keyword\r\nRule 88    reserved_languages_list -> reserved_languages_list COMMA reserved_language_keyword\r\nRule 89    reserved_language_keyword -> RES_LANG LBRACKET RBRACKET\r\nRule 90    reserved_language_keyword -> reserved_language_keyword TIMES\r\nRule 91    reserved_language_keyword -> RES_LANG\r\nRule 92    reserved_language_keyword -> empty\r\nRule 93    identifier_list -> logical_OR_expr\r\nRule 94    identifier_list -> identifier_list COMMA VERBOSE\r\nRule 95    identifier_list -> identifier_list COMMA logical_OR_expr\r\nRule 96    identifier_list -> empty\r\nRule 97    ifelse_stmt -> IF LPAREN expression RPAREN brack_stmt\r\nRule 98    ifelse_stmt -> IF LPAREN expression RPAREN brack_stmt ELSE brack_stmt\r\nRule 99    loop_stmt -> WHILE LPAREN expression RPAREN brack_stmt\r\nRule 100   loop_stmt -> FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN brack_stmt\r\nRule 101   jump_stmt -> BREAK SEMICOLON\r\nRule 102   jump_stmt -> CONTINUE SEMICOLON\r\nRule 103   jump_stmt -> RETURN logical_OR_expr SEMICOLON\r\nRule 104   empty -> <empty>\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}